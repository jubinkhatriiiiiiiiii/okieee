import {
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Text,
  View,
  FlatList,
} from 'react-native';
import Slider from '../components/Slider';
import React, {useEffect, useState, useRef, useCallback, useMemo} from 'react';
import {NativeStackScreenProps} from '@react-navigation/native-stack';
import {SearchStackParamList} from '../App';
import useThemeStore from '../lib/zustand/themeStore';
import {providerManager} from '../lib/services/ProviderManager';
import useContentStore from '../lib/zustand/contentStore';

type Props = NativeStackScreenProps<SearchStackParamList, 'SearchResults'>;

interface SearchPageData {
  title: string;
  Posts: any[];
  filter: string;
  providerValue: string;
  value: string;
  name: string;
}

interface LoadingState {
  name: string;
  value: string;
  isLoading: boolean;
  error?: boolean;
  retryCount?: number;
}

// Debounce hook for search optimization
const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

const SearchResults = React.memo(({route}: Props): React.ReactElement => {
  const {primary} = useThemeStore(state => state);
  const {installedProviders} = useContentStore(state => state);
  const [searchData, setSearchData] = useState<SearchPageData[]>([]);
  const [loading, setLoading] = useState<LoadingState[]>([]);
  const abortController = useRef<AbortController | null>(null);
  const searchStartTime = useRef<number>(0);

  // Debounce the search filter to prevent excessive API calls
  const debouncedFilter = useDebounce(route.params.filter, 200); // Reduced from 300ms

  // Memoize loading states more efficiently
  const trueLoading = useMemo(
    () =>
      installedProviders.map(item => ({
        name: item.display_name,
        value: item.value,
        isLoading: true,
        retryCount: 0,
      })),
    [installedProviders],
  );

  // Memoize update functions with better performance
  const updateSearchData = useCallback((newData: SearchPageData) => {
    setSearchData(prev => {
      // Prevent duplicate entries
      if (prev.some(item => item.providerValue === newData.providerValue)) {
        return prev.map(item =>
          item.providerValue === newData.providerValue ? newData : item
        );
      }
      return [...prev, newData].sort((a, b) => a.name.localeCompare(b.name));
    });
  }, []);

  const updateLoading = useCallback(
    (value: string, updates: Partial<LoadingState>) => {
      setLoading(prev =>
        prev.map(i => (i.value === value ? {...i, ...updates} : i)),
      );
    },
    [],
  );

  // Memoize loading completion check
  const isAllLoaded = useMemo(
    () => loading.every(i => !i.isLoading),
    [loading],
  );

  // Memoize combined data for rendering - only show providers with results
  const combinedData = useMemo(() => {
    // Only show providers that have results or are still loading
    const providersWithResults = searchData.filter(item => {
      const loadingState = loading.find(l => l.value === item.value);
      const hasResults = item.Posts && item.Posts.length > 0;

      // Show if loading or has results
      return loadingState?.isLoading || hasResults;
    });

    return providersWithResults.sort((a, b) => {
      // Sort by loading state first, then by whether they have results
      const aLoading = loading.find(l => l.value === a.value)?.isLoading || false;
      const bLoading = loading.find(l => l.value === b.value)?.isLoading || false;
      const aHasResults = a.Posts && a.Posts.length > 0;
      const bHasResults = b.Posts && b.Posts.length > 0;

      if (aLoading && !bLoading) return -1;
      if (!aLoading && bLoading) return 1;
      if (aHasResults && !bHasResults) return -1;
      if (!aHasResults && bHasResults) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [searchData, loading]);

  // Performance monitoring
  const logPerformance = useCallback((message: string) => {
    const elapsed = Date.now() - searchStartTime.current;
    console.log(`[Search Performance] ${message} - ${elapsed}ms`);
  }, []);

  useEffect(() => {
    // Clean up previous controller if exists
    if (abortController.current) {
      abortController.current.abort();
    }

    // Create a new controller for this effect
    abortController.current = new AbortController();
    const signal = abortController.current.signal;

    // Reset states when component mounts or filter changes
    setSearchData([]);
    setLoading(trueLoading);
    searchStartTime.current = Date.now();

    const getSearchResults = async () => {
      // Optimized performance settings
      const BATCH_SIZE = 2; // Increased from 1 for better performance
      const REQUEST_TIMEOUT = 10000; // Reduced from 15s for faster response
      const MAX_RESULTS_PER_PROVIDER = 8; // Reduced from 10 for faster processing
      const BATCH_DELAY = 100; // Reduced from 500ms for faster processing
      const MAX_RETRIES = 2;

      const fetchWithTimeout = async (provider: any): Promise<void> => {
        const timeoutPromise = new Promise<never>((_, reject) =>
          setTimeout(() => reject(new Error('Search timeout')), REQUEST_TIMEOUT)
        );

        const attemptFetch = async (attemptNumber: number = 1): Promise<void> => {
          try {
            const data = await Promise.race([
              providerManager.getSearchPosts({
                searchQuery: debouncedFilter,
                page: 1,
                providerValue: provider.value,
                signal: signal,
              }),
              timeoutPromise
            ]);

            // Skip updating state if request was aborted
            if (signal.aborted) return;

            // Limit results to prevent memory issues and improve speed
            const limitedData = data ? data.slice(0, MAX_RESULTS_PER_PROVIDER) : [];

            if (limitedData && limitedData.length > 0) {
              const newData = {
                title: provider.display_name,
                Posts: limitedData,
                filter: debouncedFilter,
                providerValue: provider.value,
                value: provider.value,
                name: provider.display_name,
              };
              updateSearchData(newData);
              logPerformance(`‚úÖ ${provider.display_name}: ${limitedData.length} results`);
            } else {
              logPerformance(`‚ö†Ô∏è ${provider.display_name}: No results`);
            }

            updateLoading(provider.value, {isLoading: false, error: false});
          } catch (error: any) {
            if (signal.aborted || error?.message === 'Search timeout') {
              logPerformance(`‚è≠Ô∏è ${provider.display_name}: Aborted/Timeout`);
              updateLoading(provider.value, {isLoading: false, error: true});
              return;
            }

            console.warn(
              `Search failed for ${provider.display_name} (attempt ${attemptNumber}):`,
              error?.message || error,
            );

            // Retry logic for failed requests
            if (attemptNumber < MAX_RETRIES) {
              logPerformance(`üîÑ ${provider.display_name}: Retrying (${attemptNumber}/${MAX_RETRIES})`);
              await new Promise(resolve => setTimeout(resolve, 1000 * attemptNumber));
              return attemptFetch(attemptNumber + 1);
            }

            updateLoading(provider.value, {isLoading: false, error: true});
            logPerformance(`‚ùå ${provider.display_name}: Failed after ${MAX_RETRIES} attempts`);
          }
        };

        return attemptFetch();
      };

      // Process providers in optimized batches
      for (let i = 0; i < installedProviders.length; i += BATCH_SIZE) {
        const batch = installedProviders.slice(i, i + BATCH_SIZE);
        const batchPromises = batch.map(fetchWithTimeout);

        // Use Promise.allSettled for better error handling
        await Promise.allSettled(batchPromises);

        // Reduced delay between batches for faster processing
        if (i + BATCH_SIZE < installedProviders.length && !signal.aborted) {
          await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
        }
      }

      logPerformance('üèÅ Search completed');
    };

    // Only run search if debounced filter is not empty
    if (debouncedFilter.trim()) {
      getSearchResults();
    } else {
      // Reset loading state if search is empty
      setLoading(trueLoading.map(item => ({...item, isLoading: false})));
    }

    return () => {
      // Cleanup function: abort any ongoing API requests
      if (abortController.current) {
        abortController.current.abort();
        abortController.current = null;
      }
    };
  }, [
    debouncedFilter,
    trueLoading,
    installedProviders,
    updateSearchData,
    updateLoading,
    logPerformance,
  ]);

  // Memoize render item function
  const renderItem = useCallback(
    ({item, index}: {item: SearchPageData; index: number}) => {
      const loadingState = loading.find(i => i.value === item.value);
      const hasResults = item.Posts && item.Posts.length > 0;

      return (
        <Slider
          isLoading={loadingState?.isLoading || false}
          key={`${item.value}-${hasResults ? 'data' : 'empty'}`}
          title={item.name}
          posts={item.Posts || []}
          filter={debouncedFilter}
          providerValue={item.value}
          isSearch={true}
        />
      );
    },
    [loading, debouncedFilter],
  );

  // Memoize key extractor
  const keyExtractor = useCallback((item: SearchPageData) => item.value, []);

  // Memoize loading indicator
  const loadingIndicator = useMemo(() => {
    if (isAllLoaded) return null;

    const loadingCount = loading.filter(l => l.isLoading).length;
    const totalCount = loading.length;

    return (
      <View className="flex justify-center items-center h-20">
        <ActivityIndicator
          size="small"
          color={primary}
          animating={true}
        />
        <Text className="text-gray-400 text-xs mt-1">
          Searching {loadingCount} of {totalCount} providers...
        </Text>
      </View>
    );
  }, [isAllLoaded, primary, loading]);

  return (
    <SafeAreaView className="bg-black h-full w-full">
      <ScrollView showsVerticalScrollIndicator={false}>
        <View className="mt-14 px-4 flex flex-row justify-between items-center gap-x-3">
          <Text className="text-white text-2xl font-semibold ">
            {isAllLoaded ? 'Searched for' : 'Searching for'}{' '}
            <Text style={{color: primary}}>"{debouncedFilter}"</Text>
          </Text>
          {loadingIndicator}
        </View>

        <View className="px-4">
          {combinedData.length > 0 ? (
            <FlatList
              data={combinedData}
              keyExtractor={keyExtractor}
              renderItem={renderItem}
              showsVerticalScrollIndicator={false}
              removeClippedSubviews={true}
              maxToRenderPerBatch={2} // Reduced for better performance
              windowSize={3} // Reduced for better performance
              initialNumToRender={1} // Reduced for faster initial render
              getItemLayout={(data, index) => ({
                length: 280, // Slightly reduced height estimate
                offset: 280 * index,
                index,
              })}
              // Add performance optimizations
              updateCellsBatchingPeriod={50}
              contentInsetAdjustmentBehavior="automatic"
            />
          ) : (
            isAllLoaded && (
              <View className="flex-1 justify-center items-center mt-20">
                <Text className="text-white text-lg">No results found</Text>
                <Text className="text-gray-400 text-sm mt-2">
                  Try searching with different keywords
                </Text>
              </View>
            )
          )}
        </View>
        <View className="h-16" />
      </ScrollView>
    </SafeAreaView>
  );
});

export default SearchResults;
